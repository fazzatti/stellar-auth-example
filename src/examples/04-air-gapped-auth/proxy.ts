import {
  Account,
  Keypair,
  nativeToScVal,
  Operation,
  TimeoutInfinite,
  TransactionBuilder,
  xdr,
} from "@stellar/stellar-sdk";
import { config, getRpc } from "../../config/env.ts";
import { Api } from "stellar-sdk/rpc";

import { readFromJsonFile, saveToJsonFile } from "../../utils/io.ts";
import {
  AuthEntryParams,
  authEntryToParams,
  paramsToAuthEntry,
} from "../../utils/auth-entries.ts";
import { getExpirationLedger } from "../../utils/get-expiration-ledger.ts";
import { saveTransactionXdr } from "../../utils/save-transaction.ts";
import {
  ProxyAuthInput,
  ProxyAuthInputRaw,
  ProxyAuthInputXdr,
  ProxyConfig,
  ProxyInput,
  AirGappedAuthInputXdr,
  AirGappedAuthInput,
  AirGappedAuthInputRaw,
  AirGappedSignInput,
} from "./types.ts";
import { getOutputFormatArg } from "../../utils/get-output-format-arg.ts";
import { highlightText } from "../../utils/highlight-text.ts";

const { io, network } = config;
const rpc = getRpc();
const outputFormat = getOutputFormatArg();

// Load the configuration of the Proxy environment.
// Here all it needs it the secret key of the low-level account
// used to authorize transactions for submission. Responsible for
// the consumed sequence number and network fees
const configArgs = await readFromJsonFile<ProxyConfig>(io.proxyConfigFileName);
const { sourceSk } = configArgs;

const proxyKeypair = Keypair.fromSecret(sourceSk);

// Load the arguments provided by the user.
// These are the arguments detailing what contract invocation
// this transaction should perform.
// When 'auth' parameters are also provided, this means the
// transaction can be submitted and the authorization signatures
// were generated by the airgapped environment.
const inputArgs = await readFromJsonFile<ProxyInput>(io.proxyInputFileName);
const {
  contractId,
  function: fnName,
  functionArgs,
  auth: authInput,
} = inputArgs;

console.log(
  highlightText(
    `
===============================================================
Running the Proxy side of Example 04 - Air Gapped Auth Demo
===============================================================
`,
    "blue"
  )
);

// Determine if we're in the build phase (no auth entries provided).
// When in build phase, we are only assembling and simulating the transaction
// to provide the necessary authorization entries for the airgapped environment.
// When NOT in build phase, we expect to receive the entries authorization so
// the transaction can be fully assembled for submission.
const isBuildPhase = !authInput || authInput.length === 0;

console.log(
  highlightText(
    `Running the proxy in ${isBuildPhase ? "build" : "execution"} phase!`,
    "green"
  )
);

if (fnName !== "swap")
  throw new Error(`Invalid function name: ${fnName}. Expected: swap`);

const runProxy = async () => {
  // Assemble a simple transaction based on the
  // invocation parameters provided. This object
  // has no explicit authorization entries
  const rawTx = await assembleTransaction();

  // This step will simulate the transaction execution
  // and provide auth entries required for this invocation
  // to be successful when executed.
  const simulation = await rpc.simulateTransaction(rawTx).catch((error) => {
    console.error("Error simulating transaction:", error);
    throw error;
  });

  // Check if the simulation successfully contains the result object
  if (!(simulation as Api.SimulateTransactionSuccessResponse).result)
    throw new Error("Simulation is missing a result, cannot proceed.");

  // Extract the authorization entries from the simulation response
  const simulatedAuthEntries =
    (simulation as Api.SimulateTransactionSuccessResponse).result?.auth || [];

  // If we're in the build phase, we just need to output the auth entries
  // so the user can take these parameters to the airgapped environment
  // and sign them there.
  if (isBuildPhase) {
    await reviewAndOutputAuthorizationRequirements(simulatedAuthEntries);
    return;
  }

  const requiredAuthEntries = getRequiredAuthorizationEntries(
    simulatedAuthEntries
  ) as xdr.SorobanAuthorizationEntry[];

  const authorizedEntries = loadAuthorizedEntries(
    authInput,
    requiredAuthEntries
  );

  const txWithEntries = await assembleTransaction(authorizedEntries);

  const preparedTx = await rpc.prepareTransaction(txWithEntries);

  preparedTx.sign(proxyKeypair);

  console.log("Signed Transaction:\n\n", preparedTx.toXDR(), "\n\n");

  saveTransactionXdr(preparedTx.toXDR());

  // const suggestedExpirationLedger = await getExpirationLedger(600);

  // const authEntriesParams = getAuthorizationEntries(
  //   simulation,
  //   suggestedExpirationLedger
  // );

  // const authorizedEntries = isBuildPhase ? undefined : loadAuthorizedEntries();
};

// Function that constructs the transaction object
// based on the input parameters. Optionally receives
// the authorization entry objects to include in the transaction.
// These will be added once they're fully signed by the
// airgapped environment.
const assembleTransaction = async (
  authEntries?: xdr.SorobanAuthorizationEntry[]
) => {
  // ===================================================
  // Encode the arguments for a 'swap' invocation
  // ===================================================
  //
  // Boolean to indicate if the swap is for asset A or B
  const scValIsSellAssetA = nativeToScVal(functionArgs.isSellAssetA, {
    type: "bool",
  });
  // The address of the account performing the swap
  const scValuAccount = nativeToScVal(functionArgs.userPk, {
    type: "address",
  });
  // The amount to swap
  const scValAmount = nativeToScVal(functionArgs.amount, {
    type: "i128",
  });
  // Arrange Args into an array
  const args: xdr.ScVal[] = [scValIsSellAssetA, scValuAccount, scValAmount];

  // ===================================================
  // Prepare additional data for the transaction
  // ===================================================
  //
  // The inclusion fee is the fee charged for including the transaction in a ledger.
  const inclusionFee = 1000;
  //
  // User the RPC to load the source account data from the ledger
  // This ensures the account exists and also retrieves the current sequence number
  // Here we're using the source account from the proxy configuration.
  let proxyAccount: Account;
  try {
    proxyAccount = await rpc.getAccount(proxyKeypair.publicKey());
  } catch (error) {
    console.error("Error checking source account:", error);
    throw error;
  }

  // ===================================================
  // Assemble the transaction object
  // ===================================================
  const tx = new TransactionBuilder(proxyAccount, {
    fee: inclusionFee.toString(),
    networkPassphrase: network,
  })
    .addOperation(
      Operation.invokeContractFunction({
        contract: contractId,
        function: fnName,
        args,
        auth: authEntries, // When signed auth entries are present, these are included directly in the contract invocation operation
      })
    )
    .setTimeout(TimeoutInfinite)
    .build();

  return tx;
};

// Function to extract authorization entries from the simulation response
// that require individual signing to authorize.
const getRequiredAuthorizationEntries = (
  entries: xdr.SorobanAuthorizationEntry[],
  suggestedExpirationLedger?: number,
  convertToRawParameters = false
): AuthEntryParams[] | xdr.SorobanAuthorizationEntry[] => {
  const outputEntries = [];

  for (const entry of entries) {
    if (entry.credentials().switch().name === "sorobanCredentialsSourceAccount")
      continue; // Source account entry, no need to sign the entry

    // Convert the entry object to a simplified format
    // with just raw parameters necessary to reassemble
    // this object in the airgapped environment.
    if (convertToRawParameters) {
      if (!suggestedExpirationLedger)
        throw new Error(
          "Suggested expiration ledger is required for raw parameters"
        );

      const entryParams = authEntryToParams(entry);
      entryParams.credentials.signatureExpirationLedger =
        suggestedExpirationLedger;
      outputEntries.push(entryParams);
      continue;
    }

    // If no conversion is requested, push the original entry
    outputEntries.push(entry);
  }

  // Separate the output type based on the conversion flag
  // to aid typescript's type inference
  if (convertToRawParameters) return outputEntries as AuthEntryParams[];
  return outputEntries as xdr.SorobanAuthorizationEntry[];
};

const reviewAndOutputAuthorizationRequirements = async (
  authEntries: xdr.SorobanAuthorizationEntry[]
) => {
  // Given the latest ledger, calculate a suggested expiration ledger 600 mins from now.
  // When generating the signature in the airgapped environment, the user has the choice
  // to use the suggested expiration or set a custom one for their signatures.
  const suggestedExpirationLedger = await getExpirationLedger(600);

  // Extract only the relevant entries for signing and format the output
  let output: AirGappedAuthInput;
  if (outputFormat === "xdr") {
    // Separate only the entries that need to be signed in the airgapped environment.
    const requiredAuthEntries = getRequiredAuthorizationEntries(
      authEntries
    ) as xdr.SorobanAuthorizationEntry[];

    output = {
      entriesXdr: requiredAuthEntries.map((entry) => entry.toXDR("base64")),
      signatureExpirationLedger: suggestedExpirationLedger,
    } as AirGappedAuthInputXdr;
  } else {
    // Separate only the entries that need to be signed in the airgapped environment
    // and convert them to the simplified parameter format.
    const requiredAuthEntries = getRequiredAuthorizationEntries(
      authEntries,
      suggestedExpirationLedger,
      outputFormat === "raw"
    );
    output = { rawEntries: requiredAuthEntries } as AirGappedAuthInputRaw;
  }

  console.log(
    "The transaction was successfully simulated and the authorization requirements were extracted."
  );
  console.log(
    `Updating the ${highlightText(
      io.airGappedInputFileName + ".json",
      "yellow"
    )} file with the parameters of this invocation.`
  );
  console.log(
    `The auth entries details will be saved as ${highlightText(
      outputFormat === "raw" ? "raw parameters" : "encoded XDR entries",
      "yellow"
    )}.`
  );

  const aigappedInput: AirGappedSignInput = {
    contractId,
    function: fnName,
    functionArgs,
    auth: output,
  };

  await saveToJsonFile<AirGappedSignInput>(
    aigappedInput,
    io.airGappedInputFileName
  );
};

const loadAuthorizedEntries = (
  authInput: ProxyAuthInput[],
  requiredAuthEntries?: xdr.SorobanAuthorizationEntry[]
): xdr.SorobanAuthorizationEntry[] => {
  const loadedEntries: xdr.SorobanAuthorizationEntry[] = [];

  let index = -1;
  for (const signedEntry of authInput) {
    index++;
    const signedEntryXdr = (signedEntry as ProxyAuthInputXdr).authEntryXdr;
    if (signedEntryXdr) {
      loadedEntries.push(
        xdr.SorobanAuthorizationEntry.fromXDR(signedEntryXdr, "base64")
      );
      continue;
    }

    const signedEntryRaw = signedEntry as ProxyAuthInputRaw;

    if (
      signedEntryRaw.signature &&
      signedEntryRaw.nonce &&
      signedEntryRaw.signatureExpirationLedger
    ) {
      // When assembling signed entries from raw parameters,
      // we need the entries provided by the simulation to
      // construct the object.
      if (!requiredAuthEntries) {
        throw new Error("Required authorization entries are missing.");
      }

      const parsedRequiredEntry = authEntryToParams(requiredAuthEntries[index]);

      parsedRequiredEntry.credentials.signature = signedEntryRaw.signature;
      parsedRequiredEntry.credentials.nonce = signedEntryRaw.nonce;
      parsedRequiredEntry.credentials.signatureExpirationLedger =
        signedEntryRaw.signatureExpirationLedger;
      const updatedEntry = paramsToAuthEntry(parsedRequiredEntry);
      loadedEntries.push(updatedEntry);

      continue;
    }

    throw new Error(
      `Invalid auth entry format for entry: ${JSON.stringify(signedEntry)}`
    );
  }

  return loadedEntries;
};

await runProxy();

// const tx = await assembleTransaction();

// if (isBuildPhase) {
//   const simulation = (await rpc.simulateTransaction(
//     tx
//   )) as Api.SimulateTransactionSuccessResponse;

//   const suggestedExpirationLedger = await getExpirationLedger(600);

//   const authEntriesParams = getAuthorizationEntries(
//     simulation,
//     suggestedExpirationLedger
//   );

//   // const entries = simulation.result?.auth;
//   // if (!entries || entries.length === 0) {
//   //   throw new Error("No auth entries found in simulation");
//   // }

//   // Output the transaction and auth entries
//   // console.log("Transaction XDR:", tx.toXDR());
//   // console.log("Authorization Entries:", JSON.stringify(authEntries, null, 2));

//   // const entriesXdr = entries.map((entry) => entry.toXDR("base64"));

//   console.log("Authorization Entries:", authEntriesParams);

//   const aigappedInput: AirGappedSignInput = {
//     contractId,
//     function: fnName,
//     functionArgs,
//     authEntries: authEntriesParams,
//   };

//   await saveToJsonFile<AirGappedSignInput>(
//     aigappedInput,
//     io.airGappedInputFileName
//   );

//   Deno.exit(0);
// }

// if (!isBuildPhase) {
//   if (!authInput || authInput.length === 0)
//     throw new Error("No signed auth entries provided for submission.");

//   const simulation = (await rpc.simulateTransaction(
//     tx
//   )) as Api.SimulateTransactionSuccessResponse;

//   const updatedEntries = [];
//   let nextIndex = 0;
//   for (const entry of simulation.result?.auth || []) {
//     if (
//       entry.credentials().switch().name === "sorobanCredentialsSourceAccount"
//     ) {
//       updatedEntries.push(entry);
//       continue; // Source account entry, no need to sign the entry individually
//     }

//     const entryParams = authEntryToParams(entry);

//     console.log("Updating entry:", entryParams);
//     entryParams.credentials.signature = signedAuthEntries[nextIndex].signature;
//     entryParams.credentials.nonce = signedAuthEntries[nextIndex].nonce;
//     entryParams.credentials.signatureExpirationLedger =
//       signedAuthEntries[nextIndex].signatureExpirationLedger;
//     console.log("Updated entry:", entryParams);

//     const updatedEntry = paramsToAuthEntry(entryParams);

//     updatedEntries.push(updatedEntry);

//     nextIndex++;
//   }

//   const transactionData = simulation.transactionData.build();
//   const resourceFee = Number(transactionData.resourceFee().toBigInt());
//   const op = tx.toEnvelope().v1().tx().operations()[0];

//   // Here we add the signed entries to the operation object
//   const authorizedOperation = Operation.invokeHostFunction({
//     func: op.body().invokeHostFunctionOp().hostFunction(),
//     auth: updatedEntries,
//   });

//   // When a transaction object is assembled, the sequence is automatically bumped
//   // to the next sequence number, so we need to ensure that the source account
//   // sequence number is not bumped by the transaction builder again.
//   const updatedSourceAccount = new Account(
//     tx.source,
//     (Number(tx.sequence) - 1).toString()
//   );

//   // The inclusion fee is the fee charged for including the transaction in a ledger
//   const inclusionFee = tx.fee;

//   const updatedTx = new TransactionBuilder(updatedSourceAccount, {
//     fee: (inclusionFee + resourceFee).toString(),
//     networkPassphrase: network,
//     sorobanData: transactionData,
//     timebounds: tx.timeBounds,
//     minAccountSequence: tx.minAccountSequence,
//     minAccountSequenceAge: tx.minAccountSequenceAge,
//     minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
//   });

//   updatedTx.addOperation(authorizedOperation);

//   const finalTx = updatedTx.build();

//   const preparedTx = await rpc.prepareTransaction(finalTx);

//   preparedTx.sign(proxyKeypair);

//   console.log("Signed Transaction:\n\n", preparedTx.toXDR(), "\n\n");

//   saveTransactionXdr(preparedTx.toXDR());
// }

// // const { step } = args;

// // if (!step) {
// //   console.error(
// //     "No step provided in args, make sure to inclue a '--step=<step>' argument"
// //   );
// //   console.error(
// //     "Available steps: \n 'build': Builds a transaction and outputs the auth entries to be authorized by the air-gapped secure account. \n 'send': Receives the signed auth entry and completes the transaction."
// //   );

// //   Deno.exit(1);
// // }

// // if (step === "build") {

// // }
