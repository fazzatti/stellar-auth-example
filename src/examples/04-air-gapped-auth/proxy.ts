import {
  Account,
  Keypair,
  nativeToScVal,
  Operation,
  TimeoutInfinite,
  TransactionBuilder,
  xdr,
} from "@stellar/stellar-sdk";
import { config, getRpc } from "../../config/env.ts";
import { Api } from "stellar-sdk/rpc";

import { readFromJsonFile, saveToJsonFile } from "../../utils/io.ts";
import {
  AuthEntryParams,
  authEntryToParams,
  paramsToAuthEntry,
} from "../../utils/auth-entries.ts";
import { getExpirationLedger } from "../../utils/get-expiration-ledger.ts";
import { saveTransactionXdr } from "../../utils/save-transaction.ts";
import {
  ProxyAuthInput,
  ProxyAuthInputRaw,
  ProxyAuthInputXdr,
  ProxyConfig,
  ProxyInput,
  AirGappedAuthInputXdr,
  AirGappedAuthInput,
  AirGappedAuthInputRaw,
  AirGappedSignInput,
} from "./types.ts";
import { getOutputFormatArg } from "../../utils/get-output-format-arg.ts";
import { highlightText } from "../../utils/highlight-text.ts";

const { io, network } = config;
const rpc = getRpc();
const outputFormat = getOutputFormatArg();

// Load the configuration of the Proxy environment.
// Here all it needs it the secret key of the low-level account
// used to authorize transactions for submission. Responsible for
// the consumed sequence number and network fees
const configArgs = await readFromJsonFile<ProxyConfig>(io.proxyConfigFileName);
const { sourceSk } = configArgs;

const proxyKeypair = Keypair.fromSecret(sourceSk);

// Load the arguments provided by the user.
// These are the arguments detailing what contract invocation
// this transaction should perform.
// When 'auth' parameters are also provided, this means the
// transaction can be submitted and the authorization signatures
// were generated by the airgapped environment.
const inputArgs = await readFromJsonFile<ProxyInput>(io.proxyInputFileName);
const {
  contractId,
  function: fnName,
  functionArgs,
  auth: authInput,
} = inputArgs;

console.log(
  highlightText(
    `
===============================================================
Running the Proxy side of Example 04 - Air Gapped Auth Demo
===============================================================
`,
    "blue"
  )
);

// Determine if we're in the build phase (no auth entries provided).
// When in build phase, we are only assembling and simulating the transaction
// to provide the necessary authorization entries for the airgapped environment.
// When NOT in build phase, we expect to receive the entries authorization so
// the transaction can be fully assembled for submission.
const isBuildPhase = !authInput || authInput.length === 0;

console.log(
  highlightText(
    `Running the proxy in ${isBuildPhase ? "build" : "execution"} phase!`,
    "green"
  )
);

// Main workflow that executes when Proxy runs
const runProxy = async () => {
  if (fnName !== "swap")
    throw new Error(`Invalid function name: ${fnName}. Expected: swap`);

  // Assemble a simple transaction based on the
  // invocation parameters provided. This object
  // has no explicit authorization entries
  const rawTx = await assembleTransaction();

  // This step will simulate the transaction execution
  // and provide auth entries required for this invocation
  // to be successful when executed.
  const simulation = await rpc.simulateTransaction(rawTx).catch((error) => {
    console.error("Error simulating transaction:", error);
    throw error;
  });

  // Check if the simulation successfully contains the result object
  if (!(simulation as Api.SimulateTransactionSuccessResponse).result)
    throw new Error("Simulation is missing a result, cannot proceed.");

  // Extract the authorization entries from the simulation response
  const simulatedAuthEntries =
    (simulation as Api.SimulateTransactionSuccessResponse).result?.auth || [];

  // If we're in the build phase, we just need to output the auth entries
  // so the user can take these parameters to the airgapped environment
  // and sign them there.
  if (isBuildPhase) {
    await reviewAndOutputAuthorizationRequirements(simulatedAuthEntries);
    return;
  }

  // Get just the entries that need to be signed from the simulation
  const requiredAuthEntries = getRequiredAuthorizationEntries(
    simulatedAuthEntries
  ) as xdr.SorobanAuthorizationEntry[];

  // Load the authorization provided in the input file
  // and reassemble the authorized objects
  const authorizedEntries = loadAuthorizedEntries(
    authInput,
    requiredAuthEntries
  );

  // Assemble the transaction with the authorized entries
  const txWithEntries = await assembleTransaction(authorizedEntries);

  // Prepare the transaction for submission. This step includes
  // a simulation step, which will verify if the transaction
  // with the authorized entries won't fail.
  // Afterwards, an updated transaction object is returned with
  // the results of the simulation.
  const preparedTx = await rpc.prepareTransaction(txWithEntries);

  // Sign the transaction object with the source account.
  // This is handled directly in the proxy as a low-risk
  // account is used for this purpose.
  preparedTx.sign(proxyKeypair);

  console.log("Signed Transaction:\n\n", preparedTx.toXDR(), "\n\n");

  // Save the signed transaction XDR to a file
  saveTransactionXdr(preparedTx.toXDR());
};

// Function that constructs the transaction object
// based on the input parameters. Optionally receives
// the authorization entry objects to include in the transaction.
// These will be added once they're fully signed by the
// airgapped environment.
const assembleTransaction = async (
  authEntries?: xdr.SorobanAuthorizationEntry[]
) => {
  // ===================================================
  // Encode the arguments for a 'swap' invocation
  // ===================================================
  //
  // Boolean to indicate if the swap is for asset A or B
  const scValIsSellAssetA = nativeToScVal(functionArgs.isSellAssetA, {
    type: "bool",
  });
  // The address of the account performing the swap
  const scValuAccount = nativeToScVal(functionArgs.userPk, {
    type: "address",
  });
  // The amount to swap
  const scValAmount = nativeToScVal(functionArgs.amount, {
    type: "i128",
  });
  // Arrange Args into an array
  const args: xdr.ScVal[] = [scValIsSellAssetA, scValuAccount, scValAmount];

  // ===================================================
  // Prepare additional data for the transaction
  // ===================================================
  //
  // The inclusion fee is the fee charged for including the transaction in a ledger.
  const inclusionFee = 1000;
  //
  // User the RPC to load the source account data from the ledger
  // This ensures the account exists and also retrieves the current sequence number
  // Here we're using the source account from the proxy configuration.
  let proxyAccount: Account;
  try {
    proxyAccount = await rpc.getAccount(proxyKeypair.publicKey());
  } catch (error) {
    console.error("Error checking source account:", error);
    throw error;
  }

  // ===================================================
  // Assemble the transaction object
  // ===================================================
  const tx = new TransactionBuilder(proxyAccount, {
    fee: inclusionFee.toString(),
    networkPassphrase: network,
  })
    .addOperation(
      Operation.invokeContractFunction({
        contract: contractId,
        function: fnName,
        args,
        auth: authEntries, // When signed auth entries are present, these are included directly in the contract invocation operation
      })
    )
    .setTimeout(TimeoutInfinite)
    .build();

  return tx;
};

// Function to extract authorization entries from the simulation response
// that require individual signing to authorize.
const getRequiredAuthorizationEntries = (
  entries: xdr.SorobanAuthorizationEntry[],
  suggestedExpirationLedger?: number,
  convertToRawParameters = false
): AuthEntryParams[] | xdr.SorobanAuthorizationEntry[] => {
  const outputEntries = [];

  for (const entry of entries) {
    if (entry.credentials().switch().name === "sorobanCredentialsSourceAccount")
      continue; // Source account entry, no need to sign the entry

    // Convert the entry object to a simplified format
    // with just raw parameters necessary to reassemble
    // this object in the airgapped environment.
    if (convertToRawParameters) {
      if (!suggestedExpirationLedger)
        throw new Error(
          "Suggested expiration ledger is required for raw parameters"
        );

      const entryParams = authEntryToParams(entry);
      entryParams.credentials.signatureExpirationLedger =
        suggestedExpirationLedger;
      outputEntries.push(entryParams);
      continue;
    }

    // If no conversion is requested, push the original entry
    outputEntries.push(entry);
  }

  // Separate the output type based on the conversion flag
  // to aid typescript's type inference
  if (convertToRawParameters) return outputEntries as AuthEntryParams[];
  return outputEntries as xdr.SorobanAuthorizationEntry[];
};

const reviewAndOutputAuthorizationRequirements = async (
  authEntries: xdr.SorobanAuthorizationEntry[]
) => {
  // Given the latest ledger, calculate a suggested expiration ledger 600 mins from now.
  // When generating the signature in the airgapped environment, the user has the choice
  // to use the suggested expiration or set a custom one for their signatures.
  const suggestedExpirationLedger = await getExpirationLedger(600);

  // Extract only the relevant entries for signing and format the output
  let output: AirGappedAuthInput;
  if (outputFormat === "xdr") {
    // Separate only the entries that need to be signed in the airgapped environment.
    const requiredAuthEntries = getRequiredAuthorizationEntries(
      authEntries
    ) as xdr.SorobanAuthorizationEntry[];

    output = {
      entriesXdr: requiredAuthEntries.map((entry) => entry.toXDR("base64")),
      signatureExpirationLedger: suggestedExpirationLedger,
    } as AirGappedAuthInputXdr;
  } else {
    // Separate only the entries that need to be signed in the airgapped environment
    // and convert them to the simplified parameter format.
    const requiredAuthEntries = getRequiredAuthorizationEntries(
      authEntries,
      suggestedExpirationLedger,
      outputFormat === "raw"
    );
    output = { rawEntries: requiredAuthEntries } as AirGappedAuthInputRaw;
  }

  console.log(
    "The transaction was successfully simulated and the authorization requirements were extracted."
  );
  console.log(
    `Updating the ${highlightText(
      io.airGappedInputFileName + ".json",
      "yellow"
    )} file with the parameters of this invocation.`
  );
  console.log(
    `The auth entries details will be saved as ${highlightText(
      outputFormat === "raw" ? "raw parameters" : "encoded XDR entries",
      "yellow"
    )}.`
  );

  const aigappedInput: AirGappedSignInput = {
    contractId,
    function: fnName,
    functionArgs,
    auth: output,
  };

  await saveToJsonFile<AirGappedSignInput>(
    aigappedInput,
    io.airGappedInputFileName
  );
};

// Load the authorized entries from the air- input file
// and assemble the authorized objects
const loadAuthorizedEntries = (
  authInput: ProxyAuthInput[],
  requiredAuthEntries?: xdr.SorobanAuthorizationEntry[]
): xdr.SorobanAuthorizationEntry[] => {
  const loadedEntries: xdr.SorobanAuthorizationEntry[] = [];

  let index = -1;
  for (const signedEntry of authInput) {
    index++;

    // Check if the entry is in XDR format
    // In this case, we just need to decode the XDR
    // as it contains the entire signed object
    const signedEntryXdr = (signedEntry as ProxyAuthInputXdr).authEntryXdr;
    if (signedEntryXdr) {
      loadedEntries.push(
        xdr.SorobanAuthorizationEntry.fromXDR(signedEntryXdr, "base64")
      );
      continue;
    }

    // When not in XDR format, we need to parse the raw parameters
    // and reassemble the object based on the objects provided
    // by the simulation.
    const signedEntryRaw = signedEntry as ProxyAuthInputRaw;

    if (
      signedEntryRaw.signature &&
      signedEntryRaw.nonce &&
      signedEntryRaw.signatureExpirationLedger
    ) {
      // When assembling signed entries from raw parameters,
      // we need the entries provided by the simulation to
      // construct the object.
      if (!requiredAuthEntries) {
        throw new Error("Required authorization entries are missing.");
      }

      // Convert the object to raw parameters so we can modify it
      const parsedRequiredEntry = authEntryToParams(requiredAuthEntries[index]);

      // The authorization parts are added to the parsed object
      parsedRequiredEntry.credentials.signature = signedEntryRaw.signature;
      parsedRequiredEntry.credentials.nonce = signedEntryRaw.nonce;
      parsedRequiredEntry.credentials.signatureExpirationLedger =
        signedEntryRaw.signatureExpirationLedger;

      // The object is then reassembled from the parameters
      const updatedEntry = paramsToAuthEntry(parsedRequiredEntry);

      loadedEntries.push(updatedEntry);
      continue;
    }

    throw new Error(
      `Invalid auth entry format for entry: ${JSON.stringify(signedEntry)}`
    );
  }

  return loadedEntries;
};

// Run the proxy workflow
await runProxy();
